# LAB-AZ4

## پروفایلینگ بر روی کلاس جاواکاپ

در ابتدا همانطور که از ما خواسته شد با استفاده از YourKit عملیات پروفایلینگ را بر روی کلاس JavaCup اجرا کردیم و تابعی که بیشترین مصرف منابع را دارد را شناسایی کردیم که تابع temp بود. <br>
تابع temp در کلاس JavaCup به دلایل متعددی منابع زیادی مصرف می‌کند. این تابع یک ArrayList ایجاد می‌کند و آن را با 200 میلیون عنصر پر می‌کند که این مقدار بسیار زیادی از حافظه را مصرف می‌کند. برای اضافه کردن این تعداد زیاد عناصر، تابع از حلقه‌های تو در تو استفاده می‌کند که تعداد عملیات‌ها را به شدت افزایش می‌دهد و زمان اجرای تابع را به طور قابل توجهی بالا می‌برد. علاوه بر این، اگر ظرفیت اولیه ArrayList به طور صریح مشخص نشود، از مقدار پیش‌فرض استفاده می‌کند که معمولاً کوچک است و نیاز به تغییر اندازه مکرر دارد. هر بار که ظرفیت ArrayList پر می‌شود، یک آرایه جدید با اندازه بزرگ‌تر ایجاد می‌شود و عناصر قدیمی به آن کپی می‌شوند که این فرایند نیز به نوبه خود منابع بیشتری از حافظه و پردازش را مصرف می‌کند. به همین دلیل، تابع temp باعث مصرف زیاد منابع می‌شود. <br>
در عکس‌های زیر منابع مصرفی قبل از تغییر این کلاس را مشاهده می‌کنیم: <br> <br>
![2](https://github.com/user-attachments/assets/0d7555c6-6149-4bfe-b82c-f09e048dc4be)
![3](https://github.com/user-attachments/assets/e16779ab-6582-4bb6-922e-967959d2f57a)
![4](https://github.com/user-attachments/assets/5b80ffa4-4058-4fe7-b961-7e004f12acba)
![5](https://github.com/user-attachments/assets/25c22138-2ac2-41b4-823e-0295bcdb7809)
![6](https://github.com/user-attachments/assets/cfbc5358-8a40-4ac3-a245-3f856ebc3aeb)
![7](https://github.com/user-attachments/assets/8f7d3e7b-d723-4054-8f8e-7b69144df58a)
<br> <br> <br>
حال این تابع را کمی تغییر دادیم که در زیر عکس آن را مشاهده می‌کنید: <br> <Br>
![image](https://github.com/user-attachments/assets/321ad441-44cf-41b5-8a0f-936266a0f04e)
<br> <br> <br>
تغییری که در تابع temp انجام داده‌ایم، تعیین ظرفیت اولیه ArrayList به اندازه 200 میلیون عنصر است. در این کد جدید، ArrayList با ظرفیت اولیه 200 میلیون عنصر ایجاد می‌شود. <br>
این تغییر به دلایل متعددی تاثیرگذار است. ابتدا، با تعیین ظرفیت اولیه ArrayList به اندازه 200 میلیون عنصر، نیاز به تغییر اندازه مکرر آرایه درونی ArrayList از بین می‌رود. در پیاده‌سازی اولیه، هر بار که ظرفیت ArrayList پر می‌شد، یک آرایه جدید با اندازه بزرگ‌تر ایجاد و عناصر قدیمی به آن کپی می‌شدند. این عملیات‌های زمان‌بر و منابع‌بر با این تغییر کاهش می‌یابند. <br>
دوم، کاهش عملیات تغییر اندازه موجب کاهش مصرف دسترسی به حافظه می‌شود. عملیات تغییر اندازه مکرر نیاز به تخصیص و آزادسازی پی‌در‌پی حافظه دارد که می‌تواند منجر به مصرف بالای دسترسی به حافظه شود. با مشخص کردن ظرفیت اولیه، نیاز به این عملیات‌ها کاهش می‌یابد و دسترسی به حافظه بهینه‌تر می‌شود. <br>
سوم، این تغییر باعث بهبود کارایی تابع می‌شود. با کاهش عملیات تغییر اندازه و کپی عناصر، زمان اجرای تابع نیز بهبود می‌یابد. این بهبود کارایی به خصوص در برنامه‌هایی با حجم بزرگ داده‌ها محسوس است. <br>
حال در زیر تصاویر مربوط به انجام عملیات پروفایلینگ را بر روی کلاس جاواکاپ با متد تغییر یافته می‌بینیم: <br> <br>
![8](https://github.com/user-attachments/assets/f03808c6-20aa-4f4e-b11e-298cede6adde)
![9](https://github.com/user-attachments/assets/bea97d64-49b8-402f-984a-2be0134c89fc)
![10](https://github.com/user-attachments/assets/9d18764d-64f0-44ae-b865-7f134cad4a6c)
![11](https://github.com/user-attachments/assets/76cba41a-d0f9-4510-8497-e4e4156248e5)
![12](https://github.com/user-attachments/assets/4de6cd59-4f54-48da-a19b-7fa21b6579bd)
![13](https://github.com/user-attachments/assets/de82c5fb-f4e2-4de9-85f6-900df116f63c)
<br> <br> <br>
همانطور که مشاهده میکنید استفاده از منابع و زمان اجرا کاهش یافته است. <br>










